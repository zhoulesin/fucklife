# Android6.0以下的双进程守护

## 常见的Android应用保活方法

### 监听广播方式

通过监听一些全局的静态广播,比如开机广播,解锁屏广播,网络状态广播等,来启动应用的后台服务.目前在高版本的Android系统中已经失效,因为高版本的Android系统规定应用必须在系统开机后运行一次才能监听这些系统广播,一般而言,应用被系统杀死后,基本无法接受系统广播

### 提高service优先级

以前提高service优先级的方法很多,比如onStartCommand返回START_STICKY是系统内存足够的时候service能够自动启动,弹出通知,配置service的优先级等,这些方式只能在一定程度上缓解service被立马回收,但只要用户一键清理或者系统回收照样无效

### 全局定时器

设置一种全局定时器,定时检测启动后台服务,但这种方法目前也已经无效,因为应用只要被系统杀死,全局定时器也成了摆设

### 应用中双service拉起

经过测试,只要当前应用被杀,任何后台service都无法运行,也无法自行启动

### 应用中的双进程拉起

这种方式就是传说中的使用NDK在底层fork出一个子进程,来实现与父进程之间的互拉.在android4.x还是非常有效的,但是高版本的Android系统的系统回收策略已经改成进程组的形式了,如果系统要回收一个应用,必然会杀死同属于一个进程组的所有进程,因此最后导致双进程无法拉起

## 剖析Android的Service

Service的特征类似于Activity,其区别是他没有交互界面,且可长时间运行在后台,即使它所属的应用已经退出,Service仍然可以继续在后台运行.service无法自行启动,访问者启动它的方式分为两种,即startService和bindService.

- startService:访问者使用这种方式启动service后,被启动的service将不受访问者控制,也无法与访问者进行数据通信,他会无限地运行下去,必须调用stopSelf方法或者其他组件调用stopService方法来停止.
- bindService:访问者使用这种方式启动service后,被启动的service受访问者的控制,访问者将通过一个IBinder接口的对象与被绑定的service进行通信,并且可以通过unbindService方法随时关闭service.一个service可以同时被多个访问者绑定,只有当多个访问者都主动接触绑定关系之后,系统才会销毁service.

## 理解AIDL和远程service调用

本地service是指绑定启动的service实现在它所属的应用进程中,其他组件访问者与本地service之间的通信是通过IBinder接口对象实现的;远程service是指绑定启动的service实现在其他应用进程中,也就是另一个APP中,他们之间的通信则是通过IBinder接口的代码对象实现的,而这个代理独享必须通过AIDL方式来构造

AIDLAndroid Interface Definition Language 接口描述语言,使用用于约束两个进程之间通讯的规则,可以实现android终端上两个不同应用(进程)之间的通信IPC

AIDL的实现很简单

- 在A应用创建IPerson.aidl接口文件
- 将创建的IPerson.aidl接口文件拷贝到B应用中

```java
package com.demo.aidl;

interface Person{
    String getName();
    int getAge();
}
```

我们只需保存.aidl文件,编译器会自动生成所需的IPerson.java文件,该文件包含一个内部类IPerson.Stub,他实际上继承与BInder对象,即充当通信所需的IBinder代理对象

## 先看看单进程守护如何实现保活

绑定service流程

以某Android应用X中的守护service启动保活助手A的守护servcie为例

- 当应用X中的service通过bindService绑定保活助手A的service时,保活助手A会回调onBInd方法返回一个IPerson.Stub的代理对象给应用X
- 当应用X的Service的onServiceConnected被回调时,说明应用X绑定保活助手A的service成功
- 当解绑时,应用X中的onServiceDIsconnected和保活助手A的onUnbind被调用

有了前面的基础,接下来就分析如何在不同的应用进程中创建守护service,通过检测彼此的绑定情况来唤醒彼此:

- 当应用X绑定保活助手A时,如果保活助手A被系统杀死,应用X的onServiceDisconnected被回调,我们可以在该方法中执行bindService方法再次尝试绑定唤醒保活助手A
- 当保活助手A绑定应用X时,如果应用X被系统杀死,保活助手A的onServiceDIsconnected被回调,我们可以在该方法中执行bindService方法再次尝试绑定唤醒应用X

至此,经过这种双重绑定来达到应用保活的目的

只提高保活助手A的service优先级,而不同时提高应用X的优先级?

这是因为在测试的过程中发现:当上述两个进程长时间运行在后台时还是有可能被系统杀死,以致无法实现保活的目的.当时猜想系统在回收进程时很可能是按顺序回收的,当着两个进程顺序比较接近,或者说内存中可能就只有这里两个进程,那么系统在回收的时候一次性将其都干掉了.为了缓解这种情况,我采取了一种高低优先级的方式来尽量保证系统不会同一时间回收两个进程,只要有了这个时间差,两个进程就能够实现互相启动保活的目的.

## 新型双进程守护的保活实践

从程度上说,单进程守护方式差不多可以满足应用长时间保活的要求,虽说让人感觉有点冠以,但实现起来也不是很难,效果明显.

但是,随着进一步的测试,我连续两次强杀应用X,应用X就无法启动了,因为当应用X体积较大,启动前需要加载大量的静态变量或者APplication类中的变量等,导致启动较慢,当我第一次强杀应用X时,保活助手A是执行绑定启动应用X保活服务的,但我第二次强杀应用X时,保活助手A可能还未与应用X绑定,最终导致保活助手A无法检查应用X的绑定状态而失效

- 双进程守护:针对单进程守护出现的问题,当应用X体积较大时,我们可以采用双进程守护,即实现两个保活助手,他们,彼此双向绑定来对应用X进行守护.我们采用环的形式来进行互拉,无论谁被杀死,只要系统杀掉剩余的任何一个进程,最后或者的进程都能够将其他被杀进程拉起来.当然,这里有个小技巧,为了防止两个保活助手进程同时被系统杀死,我这里采取高低优先级的方式来解决


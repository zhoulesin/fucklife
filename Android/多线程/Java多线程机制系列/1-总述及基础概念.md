https://www.cnblogs.com/mengheng/p/3490693.html

## 总述

在jdk5之前,java的多线程一直是个软肋,只有synchronized,Thread.sleep().obj.wait/notify这样有限的方法,而synchronized的效率还特别的低,开销比较大.jdk5相对于前面版本是重大改进,不仅在Java语法上有很多改进,在多线程上有了彻底的提高,其引进了并发变成大师douglea的java.util.concurrent(juc),支持了现代CPU的CAS原语,不仅在性能上有了很大提升,在自由度上也有了更多的选择,此时juc的效率在高并发环境下的效率远优于synchronized.但jdk6中对synchronized的内在机制做了大量显著的优化,加入了cas的概念以及偏向锁,轻量级锁,使得synchronized的效率与juc不相上下,且官方说后面该关键字还有继续优化的空间,所以现在jdk7时代,synchronized已经成为一般情况下的首选,在某些特殊场景--如可中断的锁,条件锁,等待获得锁一段时间如果失败则停止--下,juc是适用的,所以对于多线程的研究来说,了解其原理以及各自适用的场景是必要的.

## 基本概念

### 1.线程

线程是依附于进程的,进程是分配资源的最小单位,一个进程可以生成多个线程,这些线程拥有共享的进程资源.就每个线程而言,只有很少的独有资源,如控制线程运行的线程控制块,保留局部变量和少数参数的栈空间等.线程有就绪,阻塞和运行三种状态,并可以在这之间切换.也正因为多个线程会共享进程资源,所以当它们对同一个共享变量/对象进行操作的时候,线程的冲突和不一致性就产生了.

多线程并发环境下,本质上要解决的是这两个问题:

- 线程之间如何通信
- 线程之间如何同步

概况的说:线程之间如何正确的通信.虽然说的是java层面如何保证,但会涉及到java虚拟机,java内存模型,以及java这样的高级语言最终是要映射到CPU来执行.

### 2.锁

当多个线程对同一个共享变量/对象进行操作,即时是最简单的操作,如i++,在处理上实际也涉及到读取,自增,赋值这三个操作,也就是说这中间存在时间差,导致多个线程没有按照如程序编写所设想的去顺序执行,出现错位,从而导致最终结果与预期不一致.

Java多线程同步是通过锁的概念来体现.锁不是一个对象,不是一个具体的东西,而是一种机制的名称.锁机制需要保证如下两个特性

- 互斥性:即在同一时间只允许一个线程持有某个对象锁,通过这种特性来实现多线程中的协调机制,这样在同一时间只有一个线程对需同步的代码块进行访问.互斥性我们往往也成为操作的原子性
- 可见性:必须确保在锁被释放前,对共享变量所做的修改,对于随后获得该锁的另一个线程是可见的(即在获得锁时应获得最新共享变量的值),否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致

上面说的"持有某个对象锁"不太好理解.这里暂时理解为:对对象的占有权.持有某个对象锁,就是告诉大家,这个对象现在归我所有,在我没释放之前,别人不能占用这个对象.

线程持有对象锁的目的,并不是仅仅拿着,而是表明拥有了代码段的执行权,别的线程没有拿到对象锁,也就不能执行拿到锁和释放锁之间的代码.

```java
public synchronized void synMethod(){
    value++;
}
这里的锁是this


public static synchronized void method(){
	value++;
}
这里的锁是AA.class
```

互斥性和可见性,是锁机制的两个重要概念,是理解java多线程机制的基础.

### 3.挂起,休眠,阻塞与非阻塞

- 挂起suspend:当线程被挂起时,会失去cpu的使用时间,知道被其他线程唤醒
- 休眠sleep:同样会失去cpu使用时间,但是过了指定的休眠时间之后,他会自动激活,无需唤醒
- 阻塞block:在线程执行时,所需要的资源不能得到,则线程被挂起,直到满足可操作的条件
- 非阻塞block:在线程执行时,所需要的资源不能得到,则线程不是被挂起等待,而是继续执行其余事情,待条件满足了之后,收到通知再执行.

挂起了休眠时独立的操作系统的概念,而阻塞与非阻塞是在资源不能得到时的两种处理方式,不限于操作系统,当资源申请得不到时,要么挂起线程等待,要么继续执行其他操作,资源被满足后再通知该线程重新请求.虽然非阻塞的效率要高于阻塞,相应的实现的复杂度也要高一些.

在java中显式的挂起原先是通过thread的suspend方法来体现,现在此概念已经消失,suspend/resume方法已经被废弃,他们容易产生死锁,在suspend方法里的注释:当suspend的线程持有某个对象锁,而resume的线程又正好需要此锁的时候,死锁就产生了.所以下jdk版本中,挂起时jvm的系统行为,程序员无需干涉.休眠的过程中也不会释放锁,但是他一定会在某个时间后被唤醒,所以不会死锁.现在我们说的挂起,往往并非指编写者的程序里主动挂起,而是由操作系统的线程调度器去控制.所以我们常常说的"线程在申请锁失败后会被挂起,然后等待调度",这样有一定歧义,因为这里的挂起时操作系统级别的挂起,其实是在申请资源失败时的阻塞,和java中的线程的挂起不是一个概念,在后文中说的挂起,一般指的操作系统的操作,而不是thread的suspend

- wait/notify:这两个方法同样是等待/通知,但他们的前提是已经获得了锁,且在wait期间会释放锁,在wait方法里面注释:线程要调用wait方法,必须先获得该对象的锁,在调用wait之后,当前线程释放该对象锁并进入休眠,只有以下几种情况才会被唤醒:其他线程调用了该对象的notify/notifyAll,当前线程被中断,调用wait的指定时间已到

### 4.内核态与用户态

这是两个操作系统的概念.

有一些系统级的调用,比如清除时钟,创建进程等这些系统指令,如果这些底层系统级指令能够被应用程序任意访问的话,那么后果是危险的,系统随时可能崩溃,所以CPU将所执行的指令设置为多个特权级别,在硬件执行每条指令时都会校验指令的特权,比如inter x86架构的CPU将特权分为0-3四个特权级,0级的权限最高,3权限最低.

而操作系统根据这系统调用的安全性分为两种:内核态和用户态.内核态执行的指令的特权是0,用户态执行的指令的特权是3.当一个任务执行系统调用而进入内核指令执行时,我们就说进程处于内核运行态.当任务执行自己的代码的时候,就处于用户态,就像我们的class,有很多private方法,但对外公开的只有少量的public一样,这样private方法只有class本身可以调用,不允许外界调用,负责会产生意料不到的问题

在执行系统级调用时,需要将变量传递进去,可能要拷贝,计数,保存一些上下文信息,然后内核态执行完成再将参数传递到用户进程中去,这个切换的代价相对来说是比较大的,所以应该尽量避免频繁的在内核态和用户态之间切换

Java并没有自己的线程模型,而是使用了操作系统的原生线程!!!!如果要实现自己的线程模型,那么有些问题就特别复杂,难以解决,比如如何处理阻塞,如何在多CPU之间合理分配线程,如何锁定,包括创建,销毁线程...因此创建,销毁,调度,阻塞等这些事都交由操作系统来做,而线程方面的事在操作系统来说属于系统级的调用,需要在内核态完成,所以如果频繁地执行线程挂起,调度,就会频繁造成在内核态和用户态之间切换,影响效率..

我们说jdk5之前的synchronized效率低下,是因为在阻塞时线程就会被挂起,然后等待重新调度,而线程操作属于内核态,这频繁的挂起,调度使得操作系统频繁处于内核态和用户态的转换,造成频繁的变量传递,上下文保存等,从而性能较低.